import re
from rest_framework import serializers
from .models import ServiceRequest

# Define max file size (e.g., 5MB) for all uploaded files
MAX_FILE_SIZE_MB = 5
MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024


class ServiceRequestSerializer(serializers.ModelSerializer):
    """
    Serializer for creating ServiceRequest instances.
    Handles multipart/form-data, custom validation, and field mapping.
    """

    # Map frontend camelCase field names to backend snake_case model fields
    requestType = serializers.CharField(source="request_type", required=True)
    companyName = serializers.CharField(
        source="company_name", max_length=255, required=True
    )
    contactPerson = serializers.CharField(
        source="contact_person", max_length=255, required=True
    )
    companyProfile = serializers.CharField(
        source="company_profile",
        allow_blank=True,  # Frontend can send empty string
        required=False,  # Field is optional
        max_length=2000,
    )
    # The 'agreement' field is sent as the string "true" from FormData
    # We validate this string and convert it to a boolean for the model.
    # It's 'write_only' because we don't need to expose this back in the response.
    agreement = serializers.CharField(required=True, write_only=True)

    # File fields - allow them to be optional at the serializer level,
    # then enforce conditional requirements in the global `validate` method.
    licenses = serializers.FileField(required=False, allow_empty_file=True)
    managers = serializers.FileField(required=False, allow_empty_file=True)
    balance = serializers.FileField(required=False, allow_empty_file=True)

    class Meta:
        model = ServiceRequest
        fields = [
            "id",  # Read-only field, generated by the model
            "requestType",  # Mapped to request_type
            "companyName",  # Mapped to company_name
            "contactPerson",  # Mapped to contact_person
            "email",
            "phone",
            "companyProfile",  # Mapped to company_profile
            "agreement",  # Write-only field
            "licenses",
            "managers",
            "balance",
            # 'status', 'created_at', 'updated_at' are handled internally by the model
            # or in the view's response for the success message.
        ]
        read_only_fields = ["id"]  # Ensure 'id' cannot be set by the client

    def validate_requestType(self, value):
        """
        Custom validation for the 'requestType' field to ensure it's a valid choice.
        """
        allowed_choices = [choice[0] for choice in ServiceRequest.REQUEST_TYPE_CHOICES]
        if value not in allowed_choices:
            raise serializers.ValidationError(
                f"Invalid request type '{value}'. Must be one of: {', '.join(allowed_choices)}."
            )
        return value

    def validate_phone(self, value):
        """
        Custom validation for a plausible phone number format.
        This regex allows for numbers, spaces, dashes, and an optional leading plus sign.
        Adjust the regex for more specific international phone number formats if needed.
        """
        # Example regex: starts with optional '+', then 7-20 digits/spaces/dashes
        if not re.fullmatch(r"^\+?[0-9\s-]{7,20}$", value):
            raise serializers.ValidationError(
                "Please enter a valid phone number format."
            )
        return value

    def validate_agreement(self, value):
        """
        Custom validation for the 'agreement' field.
        The frontend sends the string "true". Convert it to a boolean.
        """
        if str(value).lower() != "true":
            raise serializers.ValidationError(
                "You must agree to the terms and conditions by setting 'agreement' to 'true'."
            )
        return True  # Convert the string "true" to a Python boolean True

    def _validate_file_common(self, file, field_name, allowed_extensions):
        """
        Helper method to validate file size and extension.
        """
        if not file:
            return None  # If file is optional and not provided

        # Validate file size
        if file.size > MAX_FILE_SIZE_BYTES:
            raise serializers.ValidationError(
                f"{field_name} file size ({file.size / (1024*1024):.2f}MB) "
                f"exceeds the maximum allowed size of {MAX_FILE_SIZE_MB}MB."
            )

        # Validate file extension
        # For production, consider using a library like `python-magic` for more robust
        # file type detection based on content, not just extension.
        file_extension = file.name.split(".")[-1].lower()
        if file_extension not in allowed_extensions:
            raise serializers.ValidationError(
                f"Invalid file type for {field_name}. "
                f"Allowed types are: {', '.join(allowed_extensions)}."
            )
        return file

    def validate_licenses(self, file):
        """Specific validation for the 'licenses' file."""
        return self._validate_file_common(
            file, "Licenses", ["pdf", "docx", "png", "jpg", "jpeg"]
        )

    def validate_managers(self, file):
        """Specific validation for the 'managers' file."""
        return self._validate_file_common(
            file, "Managers", ["pdf", "docx", "png", "jpg", "jpeg"]
        )

    def validate_balance(self, file):
        """Specific validation for the 'balance' file."""
        return self._validate_file_common(
            file, "Balance", ["pdf", "docx", "png", "jpg", "jpeg"]
        )

    def validate(self, data):
        """
        Performs global validation for the entire payload.
        Handles conditional requirement for the 'balance' file.
        """
        request_type = data.get(
            "request_type"
        )  # 'request_type' because of `source` mapping
        balance_file = data.get("balance")

        # Conditional requirement: 'balance' is required for 'main_facility' or 'branch_facility'
        if request_type in ["main_facility", "branch_facility"] and not balance_file:
            raise serializers.ValidationError(
                {
                    "balance": "The 'balance' file is required for 'Main Facility' and 'Branch Facility' request types."
                }
            )

        return data

    def to_representation(self, instance):
        """
        Override to_representation to control the output format,
        especially for file URLs if this serializer were used for GET.
        For this specific POST endpoint, the view's create method crafts the response.
        """
        ret = super().to_representation(instance)
        # Convert model snake_case field names back to frontend camelCase for consistency
        ret["requestType"] = ret.pop("request_type", None)
        ret["companyName"] = ret.pop("company_name", None)
        ret["contactPerson"] = ret.pop("contact_person", None)
        ret["companyProfile"] = ret.pop("company_profile", None)

        # Convert file paths to full URLs for output (if files were being returned)
        # This requires `request` in serializer context, provided by `APIView`
        request = self.context.get("request")
        if request:
            for field in ["licenses", "managers", "balance"]:
                if field in ret and ret[field]:
                    # Assumes MEDIA_URL is configured correctly for serving
                    ret[field] = request.build_absolute_uri(ret[field])
        return ret
